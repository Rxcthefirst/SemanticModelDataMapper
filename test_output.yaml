# ════════════════════════════════════════════════════════════════════════════════
# RDFMap Mapping Configuration
# ════════════════════════════════════════════════════════════════════════════════
#
# This configuration maps your data columns to ontology properties.
# Review and adjust as needed:
#   - Verify column mappings are correct
#   - Check foreign key relationships
#   - Confirm data type conversions
#
# Quick start:
#   rdfmap convert --mapping <this-file> --validate
#
# ════════════════════════════════════════════════════════════════════════════════

namespaces:
  xsd: http://www.w3.org/2001/XMLSchema#
  rdfs: http://www.w3.org/2000/01/rdf-schema#
  ex: https://example.com/mortgage#

defaults:
  base_iri: http://example.org/

sheets:
  - name: loans
    source: examples/mortgage/data/loans.csv
    
    # Main resource configuration
    row_resource:
      class: ex:MortgageLoan
      iri_template: "{base_iri}mortgage_loan/{LoanID}"
    
    # Column mappings (data properties)
    columns:
      LoanID:
        as: ex:loanNumber
        datatype: xsd:string
        required: true
      
      Principal:
        as: ex:principalAmount
        datatype: xsd:integer
        transform: to_integer
        required: true
      
      InterestRate:
        as: ex:interestRate
        datatype: xsd:decimal
        transform: to_decimal
        required: true
      
      OriginationDate:
        as: ex:originationDate
        datatype: xsd:date
        transform: to_date
        required: true
      
      LoanTerm:
        as: ex:loanTerm
        datatype: xsd:integer
        transform: to_integer
        required: true
      
      Status:
        as: ex:loanStatus
        datatype: xsd:string
        required: true
      
    # Linked objects (object properties)
    objects:
      has borrower:
        predicate: ex:hasBorrower
        class: ex:Borrower
        iri_template: "{base_iri}borrower/{BorrowerID}"
        properties:
          - column: BorrowerName
            as: ex:borrowerName
            datatype: xsd:string
            required: true
      
      collateral property:
        predicate: ex:collateralProperty
        class: ex:Property
        iri_template: "{base_iri}property/{PropertyID}"
        properties:
          - column: PropertyAddress
            as: ex:propertyAddress
            datatype: xsd:string
            required: true
      

# Processing options
options:
  on_error: "report"
  skip_empty_values: true

# ────────────────────────────────────────────────────────────────────────────────
# Validation Configuration (Optional)
# ────────────────────────────────────────────────────────────────────────────────
# Uncomment to enable SHACL validation during conversion:
#
# validation:
#   shacl:
#     enabled: true
#     shapes_file: path/to/shapes.ttl
#     inference: none  # Options: none, rdfs, owlrl
#
# This validates generated RDF against SHACL shapes to catch:
#   - Missing required properties
#   - Invalid data types
#   - Cardinality violations
#   - Domain/range mismatches
#

# ────────────────────────────────────────────────────────────────────────────────
# Ontology Imports (Optional)
# ────────────────────────────────────────────────────────────────────────────────
# Uncomment to import additional ontologies:
#
# imports:
#   - path/to/external_ontology.ttl
#   - path/to/another_ontology.owl
#
# Use this when your ontology references external vocabularies like:
#   - FOAF (Friend of a Friend)
#   - Dublin Core
#   - Schema.org
#   - Domain-specific ontologies
#

# ────────────────────────────────────────────────────────────────────────────────
# Advanced Features (Optional)
# ────────────────────────────────────────────────────────────────────────────────
#
# Multi-valued Cells:
#   columns:
#     Tags:
#       as: ex:hasTag
#       multi_valued: true
#       separator: ","  # Split "tag1,tag2,tag3" into multiple values
#
# Conditional Mapping:
#   columns:
#     Status:
#       as: ex:status
#       condition:
#         when: "value == 'Active'"
#         then: "ex:ActiveStatus"
#
# Custom Transforms:
#   columns:
#     Amount:
#       as: ex:amount
#       transform: "lambda x: float(x.replace('$', '').replace(',', ''))"
#
# Composite Keys:
#   row_resource:
#     class: ex:Transaction
#     iri_template: "{base_iri}transaction/{Date}/{AccountID}/{TransactionID}"
#
# Language Tags:
#   columns:
#     Name:
#       as: ex:name
#       language: "en"  # Add @en language tag
#
# Null Handling:
#   columns:
#     OptionalField:
#       as: ex:optional
#       skip_if_empty: true  # Don't create triple if value is null/empty
#

# ────────────────────────────────────────────────────────────────────────────────
# Additional Processing Options
# ────────────────────────────────────────────────────────────────────────────────
#
# options:
#   # CSV/TSV specific:
#   delimiter: ","           # Field separator (default: ',')
#   quote_char: '"'          # Quote character (default: '"')
#   header: true            # First row contains headers (default: true)
#   encoding: "utf-8"        # File encoding (default: 'utf-8')
#
#   # Memory management:
#   chunk_size: 1000        # Process data in chunks (for large files)
#   streaming: false        # Enable streaming mode (constant memory)
#
#   # Error handling:
#   on_error: "report"       # Options: report, skip, stop
#   skip_empty_values: true # Don't create triples for empty/null values
#   strict_mode: false      # Fail on any validation error
#
#   # Performance:
#   parallel: false         # Enable parallel processing
#   workers: 4              # Number of worker threads
#   batch_size: 10000       # RDF write batch size
#
#   # Output:
#   pretty_print: true      # Format output for readability
#   compression: "gzip"      # Compress output (gzip, bz2, xz)
#

# ════════════════════════════════════════════════════════════════════════════════
# Usage Examples
# ════════════════════════════════════════════════════════════════════════════════
#
# Test with sample data (dry run):
#   rdfmap convert --mapping <this-file> --limit 10 --dry-run
#
# Convert with validation:
#   rdfmap convert --mapping <this-file> --validate
#
# Convert to specific format:
#   rdfmap convert --mapping <this-file> --format nt --output output.nt
#
# Process large file with streaming:
#   rdfmap convert --mapping <this-file> --streaming --chunk-size 50000
#
# Generate validation report:
#   rdfmap convert --mapping <this-file> --validate --report validation.json
#
# For more information:
#   rdfmap convert --help
#   https://github.com/YourOrg/RDFMap/docs
#
# ════════════════════════════════════════════════════════════════════════════════
